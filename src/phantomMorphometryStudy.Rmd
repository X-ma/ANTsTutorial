---
title: 'Phantom Morphometry Study with *ANTsR*'
author: "Brian B. Avants et al."
date: "`r Sys.Date()`"
output:
  beamer_presentation:
    colortheme: dolphin
    fonttheme: structurebold
    highlight: tango
    incremental: yes
    theme: AnnArbor
    includes:
      in_header: mystyle.tex
    toc: yes
  ioslides_presentation:
    highlight: tango
    incremental: yes
---

```{r setup,eval=TRUE,results='hide',warning=FALSE,echo=FALSE}
# set this for your own compilation
set.seed( 11 )
library( ANTsR )
library( visreg )
bd="/Users/bavants/data/antsExamples/ANTsTutorial/"
templatefn=paste(bd,"phantomData/phantomtemplate.jpg",sep='')
if ( ! file.exists(templatefn) )
  stop( paste( "no image", templatefn ) )
allfns=Sys.glob( paste(bd,"phantomData/ph*wmgm.jpg",sep='')  )
demog=read.csv(paste(bd,'phantomData/phantpredictors.csv',sep=''))
demog$vol[ demog$vol == 1 ] = "Smaller"
demog$vol[ demog$vol == 0 ] = "Bigger"
ilist=imageFileNames2ImageList( allfns )
sccansig=0
```

# Phantom Morphometry Study

## Phantom Morphometry Study

* Manually drawn three tissue images with one group intentionally created to have a thicker "cortex"

* Brain-like, two-dimensional slices

* Pre-built template (`./ANTsTutorial/phantomData/phantomtemplate.jpg`)

* We show how to do a log-jacobian based study

* ... and a tissue study.


## Look at population: S1

```{r pop,results='asis'}
plot( ilist[[1]], window.img=c(0,255) )
```

## Look at population: S2

```{r pop2,results='asis'}
plot( ilist[[2]], window.img=c(0,255) )
```

## Look at population: S5

```{r pop5,results='asis'}
plot( ilist[[5]], window.img=c(0,255) )
```

## Look at population: S6

```{r pop6,results='asis'}
plot( ilist[[6]], window.img=c(0,255) )
```

# Segmentation

## First: segment the images

```{r segment}
template=antsImageRead( templatefn )
ilist=imageFileNames2ImageList( allfns )
plist=imageFileNames2ImageList( allfns )
for ( x in 1:length(ilist) )
  {
  mask = getMask( ilist[[ x ]] )  %>% iMath("MD",1)
  img  = antsImageClone( ilist[[ x ]] )
  km   = kmeansSegmentation(  img, k = 3, kmask = mask ) # segment
  gm   = km$probabilityimages[[2]]
  plist[[ x ]] = gm
  }
```

## Quick look at segmentation results

```{r segment1,echo=FALSE}
plot( ilist[[1]] )
```

## Quick look at segmentation results

```{r segment1b,echo=FALSE}
mask = getMask( ilist[[1]] )  %>% iMath("MD",1)
img  = ilist[[ 1 ]]
km   = kmeansSegmentation(  img, 3, mask ) # segment
plot( km$segmentation, window.img=c(0,3) )
```


# Registration

## Second: register the images

```{r register}
template = antsImageRead( templatefn )
jlist = imageFileNames2ImageList( allfns )
txList = list( )
jList2 = list( )
myvolsj = rep( NA, length( ilist ) )
myvolsi = rep( NA, length( ilist ) )
for ( x in 1:length(ilist) )
  {
  gm = plist[[x]]
  tx = antsRegistration( template, ilist[[x]], "SyNCC", 
                         gradStep = 0.1, synSampling = 1,
                         flowSigma = 3, totalSigma = 0.5,
                         regIterations = c(100,50,40) )
  gmw = antsApplyTransforms( template, gm, tx$fwdtransforms)
  plist[[ x ]] = gmw
  jlist[[ x ]] = createJacobianDeterminantImage( template,
    tx$fwdtransforms[1], 1, 0 ) %>% smoothImage(1.5)
  txList[[ x ]] = composeTransformsToField( template, tx$fwdtransforms )
  jList2[[ x ]] = createJacobianDeterminantImage(  template, txList[[ x ]] , FALSE, TRUE )
  hi = 120
  lo = 150
  myvolsi[ x ] = sum( thresholdImage( ilist[[x]], lo, hi  ) )
  myvolsj[ x ] = sum( thresholdImage( template, lo, hi ) * jList2[[ x ]] )
  }
# Validate the jacobian calculations against the "real" volume change
# We must look at both the deformable and affine component, together.
plot( myvolsi, myvolsj , main='correlation in image-based and jacobian-based volume')
hist( myvolsi - myvolsj , main='difference in volume' )
print( paste("cor:", cor( myvolsi, myvolsj  ), "err:", mean( abs( myvolsi - myvolsj ) ), "serr:", mean( myvolsi - myvolsj ) ) )
#  "cor: 0.99426596560049 err: 21.2326674573123 serr: 11.3190616928041" grad 0.05 synsampling = 1 flow 3 total 0
```


## Quick look at the template ...

```{r templ,echo=FALSE}
plot( template )
```


## And a registration

```{r regtempl,echo=FALSE}
plot( tx$warpedmovout  )
```

## And a registration overlay

```{r regtemplb,echo=FALSE}
plot( template, tx$warpedmovout %>% iMath("Canny",1,5,12),
  window.overlay=c(0.5,1)  )
```

# Jacobian


##  Now look at a log-jacobian image ...

```{r logj,echo=FALSE}
plot( jlist[[1]])
```

##  another log-jacobian image ...

```{r logjb,echo=FALSE}
plot( jlist[[5]])
```


## Now we can do statistics on either warped segmentations or the log-jacobian

.... but we should look at the demographics first.



# Statistics

## Always the first thing ...

Look at the demographics file ...

```{r demog,echo=FALSE}
knitr::kable(demog)
```

## Let's do a quick t-test on the jacobian

```{r jactt}
templatemask=getMask( template )
jmat=imageListToMatrix( jlist, templatemask )
# simple t-test to look at overall trends
rjmeans = rowMeans( jmat )
g1 = demog$vol == "Bigger"
g2 = demog$vol == "Smaller"
print( t.test( rjmeans[g1], rjmeans[g2] , paired=FALSE ) ) 
```


## Let's do a quick voxel-wise test on the jacobian

Check out `bigLMStats`. It is a great little function for
large (on the left) statistical studies ...

```{r jaclm}
demog$vol = factor( demog$vol )
umdl=lm( jmat ~ vol + gender, data=demog )
mdl=bigLMStats( umdl )
volstats=mdl$beta.pval[ "volSmaller", ]
qv=p.adjust(volstats,'BH')
qvimg=makeImage( templatemask, 1 - qv )
```

for large on the right studies, use a quick
implementation in `RcppEigen` or `RcppArmadillo`


## Look at results at one voxel

Use `visreg` to see the regression at the voxel with the maximum 
significant difference.

```{r vizjac,echo=FALSE}
vdemog = data.frame( demog, voxel = jmat[,which.min(qv)])
vmdl=lm( voxel ~ vol + gender, data=vdemog )
visreg::visreg( vmdl, "vol", main="Regression at a voxel" )
```

## Look at results in the image space

```{r jaclmviz,echo=FALSE}
plot( template, qvimg, window.overlay=c(0.95,1))
```


## Exercise ... repeat for the GM ...

...

```{r gmlm,echo=FALSE}
gmat=imageListToMatrix( plist, templatemask )
mdl=lm( gmat ~ vol + gender, data=demog )
mdl=bigLMStats( mdl )
gmstats=mdl$beta.pval[ "volSmaller", ]
gqv=p.adjust(gmstats,'BH')
gqvimg=makeImage( templatemask, 1-gqv )
```


## Exercise ... use a global covariate ...

... this is always important to think about ...


# Multivariate statistics

## Try a multivariate version of the same study

Do we believe that many aspects of cognition are fundamentally multivariate?


##  .... multivariate statistics in *R*

```{r,multivar,echo=TRUE,eval=TRUE,results='hide',warning=FALSE}
volClasses = c( rep( 1, 4 ), rep(0, 4 ) )
mypreds<-scale( as.matrix( cbind( volClasses, as.numeric( demog$gender ) ) ) )
scaledMatrix = scale( jmat )
sccan<-sparseDecom2(
  inmatrix  = list( scaledMatrix, mypreds ),
  inmask    = c( templatemask , NA ) ,
  mycoption = 0,
  sparseness=c( 0.3, 0.5 ),
  nvecs=3, its=5,
  cthresh=c(5,0),
  smooth=0.5, perms=200, robust=1 ) # might increase perms to be > 100
sccanimgs = matrixToImages( t(sccan$eig1) , templatemask )
sccansol <- sccanimgs[[1]] %>% iMath("Normalize")
```


##  Significance based on permutation testing ...

```{r multivarsig,echo=FALSE}
knitr::kable(sccan$ccasummary)
```

Exercise: What happens to the permutation based significance
when you vary parameters?

##  Visualizing multivariate statistics in *R*

```{r sccanviz,echo=FALSE,out.width='.6\\linewidth',message=FALSE,warning=FALSE,eval=TRUE}
plot( template, sccansol, window.overlay=c(0.1,1.01) )
```

# And MNI space ....

## Mapping to MNI space with *ANTsR*

* We implemented a simple approach to mapping a
custom template, and its blobs, to MNI coordinates.

* See `?getTemplateCoordinates` for an example.

* We also report summary regional labels.

* First, get a template, here the `ch2` brain.
```{r ch2}
if ( ! exists("tem") )
  tem<-antsImageRead( getANTsRData("ch2") )
```

## Mapping to MNI space with *ANTsR*

* Next, define pseudoclusters in ch2 space.
```{r defineclust}
clust <- thresholdImage( tem, 82, 90 ) %>%
   iMath("ME",1)  %>% labelClusters()
```

## Mapping to MNI space with *ANTsR*

* Download the MNI template and its labels.  
```{r mymnidl,eval=TRUE}
if ( ! exists("mymni") ) {
# try getANTsRData if you have www access
  mymni<-list( antsImageRead(getANTsRData("mni") ),
               antsImageRead(getANTsRData("mnib") ),
               antsImageRead(getANTsRData("mnia") ) )
}
```

## Mapping to MNI space with *ANTsR*

* Next define a pair of your template and its clusters.

```{r mypair,eval=TRUE}
template_cluster_pair<-list(tem,clust)
```

* Call the function to map to MNI space.
```{r mymni,eval=TRUE}
t1=Sys.time()
gcoords<-getTemplateCoordinates( template_cluster_pair ,
    mymni , convertToTal = TRUE )
t2=Sys.time()
print(t2-t1)
```

* This performs a registration and returns the coordinates for each cluster.


## Reporting cluster coordinates in MNI space with *ANTsR*

\small

Show the table of results.
```{r repomni,echo=FALSE,eval=TRUE}
knitr::kable( gcoords$templatepoints  )
```

## Review

* A simple reproducible example for a phantom morphometry study

* Plotting, segmentation, registration

* Statistics of two flavors ....

* Mapping to MNI coordinates.
